


comment 
escape sequence=> \\n
print("",end="")

variable 
datatypes
typecasting -> int("54")

string->slicing->len -> count->endswith ->capitalize()->lower()->find()

list->append->slicing -> indexing
dictionary->key value  pair->items ->keys->update
set()->add()->intersection()->remove()
--------------------------------------------------------------------------------------------------------------------------------

function and docstring:
def summing(a,b):
    """ this function does not work for three variable"""
    return a+b
summing(5,2)    /// 7

print(summing.__doc__)  // this function does not work for three variable
---------------------------------------------------------------------------------------------------------------------------------

try:
   ----
   ----
except Exceptoin as e:
   print(e)
print("This line wil print")

-------------------------------------------------------------------------------------------------------------------------------

1) Modes for file:
r   open file for reading
w   open file for writing
x   creates file if not exists
a  add more content to file
t  text mode
b binary mode
+ read and write

2) f = open("abc.txt","rt")
  a) content = f.read(no_of_character)
  b) for line in f:
         print(line)   //prints line by  
  c) f.readline()   // read only one whole line atonce
  d) f.readlines() /// all lines i.e. read whole file at once
  
  
3) f = open("abc.txt","w")
   f.write("Content to write")
   // replaces old content and writes new content
   
4)    f = open("abc.txt","a")
   f.write("Content to write")   /// appends new content in file 
   
  
5) f.tell()  // tells the character number at which pointer is currently poinitng.

6) f.seek(10)  // moves cursor to 10th character of file


7) using with block with files------
   with open("abc.txt","w") as f:
         f.read(4)  // reads 4 characters
   Now there is no need to close file. with automatically handles it.
   
   
----------------------------------------------------------------------------------------------------------------------------
Scope :

1) global variable and local variable
2) global  keyword:  it allows value's global access instead of local access.

----------------------------------------------------------------------------------------------------------------

lambda or anonymous functions:

def minus(x,y):
    return x-y
    
minus = lambda x,y :  x-y


-----------------------------------------------------------------------------------------------------------------------
Module:(prewritten package)
eg) random->>>
       random.randint(0,5)
       random.random() * 10   //// random numbers till 10
       random.choice(list_name)   // random choiced from list
       
       
 eg) audio module
 eg) video module
 eg) youtube video module
 
----------------------------------------------------------------------------------------------------------------
   
f-string and string formatting:(f-string means fast string and string  formatting means putting variable inside string)
 
 
 eg) 
                 # F strings
                import math

                me = "Harry"
                a1 =3
                # a = "this is %s " %me             /// this is harry
                # a = "this is %s %s"%(me, a1)       // this is harry 3
                # a = "This is {} {}"            
                # b = a.format(me, a1)             
                # print(b)                           //// this is harry 3 
                # a = "This is {1} {0}"            
                # b = a.format(me, a1)             
                # print(b)                           //// this is 3 harry
                a = f"this is {me} {a1} {math.cos(65)}"          
                # time
                print(a)                 // this is harry 3 0.562
  

------------------------------------------------------------------------------------------------------------

*args and **kwargs:(for variable length list and dictionary as function argument)

                        # def function_name_print(a, b, c, d, e):
                        #     print(a, b, c, d, e)

                        def funargs(normal, *argsrohan, **kwargsbala):
                            print(normal)
                            for item in argsrohan:
                                print(item)
                            print("\nNow I would Like to introduce some of our heroes")
                            for key, value in kwargsbala.items():
                                print(f"{key} is a {value}")


                        # function_name_print("Harry", "Rohan", "Skillf", "Hammad", "Shivam")

                        har = ["Harry", "Rohan", "Skillf", "Hammad",
                               "Shivam", "The programmer"]
                        normal = "I am a normal Argument and the students are:"
                        kw = {"Rohan":"Monitor", "Harry":"Fitness Instructor",
                              "The Programmer": "Coordinator", "Shivam":"Cook"}
                        funargs(normal, *har, **kw)


-------------------------------------------------------------------------------------------------------------------------------

time module:
         time.sleep(seconds)
         time.time()

------------------------------------------------------------------------------------------------------------------------------

Requirements,txt and virtual enviroment

--------------------------------------------------------------------------------------------------------------------------------

Enumerate():
for index, item in enumerate(ierable):
----------------------------------------------------------------------------------------------------------------------------


How import works:
a) import file2
   print(file2.a)
   print(file2.function_name())
  
  
b) from file2 import a
   from file import a
   
   // here is ambiguity so use in common practice as shown in (a)
   // if no ambiguity occurs then can use this format
   
   
c) import sys
    print(sys.path)   /// list of paths where our program will see for any package
    
    
 -----------------------------------------------------------------------------------------------------------------------------------
 Question) What is    If __name__==__main__   ???
 
 Answer)               --------------------------------In file1.py----------------------  
                                    def printhar(string):
                                        return f"nandan {string}"

                                    def add(num1, num2):
                                        return num1 + num2 + 5

                                    print("and the name is", __name__)          //// main
                                    if __name__ == '__main__':
                                        print(printhar("pandey"))              //// nandan pandey
                                        o = add(4, 6)
                                        print(o)                                  /// /// 15


                      --------------------------------In file2.py----------------------------
                               import file1
                               print(file1.add(5,6))           //// 16
                               print("and the name is", __name__)        ///// file1  

                    --------------------------------------------------------------------------------------------
             Without if __name__ == __main__  ==>>>all print statements are executed that exists in imported module/file 
             
                               --------------------------------In file1.py----------------------  
                                                    def printhar(string):
                                                        return f"nandan {string}"

                                                    def add(num1, num2):
                                                        return num1 + num2 + 5

                                                    print("and the name is", __name__)          //// main
                                                    
                                                        print(printhar("pandey"))          ///// nandan pandey
                                                        o = add(4, 6)
                                                        print(o)                                /// 15


                                --------------------------------In file2.py----------------------------
                                               import file1
                                               print(file1.add(5,6))           //// 16
                                                                              //// nandan pandey
                                                                              /// 15
                                               print("and the name is", __name__)        ///// file1  




---------------------------------------------------------------------------------------------------------------------------------------

join()

eg) li = ["nandan","pandey"]
    a = "and".join(li)
     print(a)              ///// nandan and pandey
--------------------------------------------------------------------------------------------------------------------------------

1) map()
-->> first argument is that function which you want to apply on all elements of list
-->> list is second argument
eg) list(map(int,my_list))




eg) num = [2,3,5,6,76,3,3,2]
# square = list(map(lambda x: x*x, num))
# print(square)




eg)  def square(a):
    return a*a
 def cube(a):
     return a*a*a
 func = [square, cube]
 num = [2,3,5,6,76,3,3,2]
 for i in range(5):
     val = list(map(lambda x:x(i), func))
     print(val)                         





2) filter()
eg) list_1 = [1,2,3,4,5,6,7,8,9]
 def is_greater_5(num):
     return num>5
gr_than_5 = list(filter(is_greater_5, list_1))
print(gr_than_5)




    


3) Reduce()
from functools import reduce
list1 = [1,2,3,4,2]
num = reduce(lambda x,y:x+y, list1)     //// 12


-----------------------------------------------------------------------------------------------------------------------------------

Decorators:

                            def dec1(func1):
                                def nowexec():
                                    print("Executing now")
                                    func1()
                                    print("Executed")
                                return nowexec

                            @dec1
                            def who_is_harry():
                                print("Harry is a good boy")

                            # who_is_harry = dec1(who_is_harry)

                            who_is_harry()
                            
                            
                            
                            
 -------------------------------------------------------------------------------------------------------------------------------
 
 Claass and objects:(class variable cannot be changed by object/instance but instance/object can access class variable)
 
 a)                     class Employee:
                            no_of_leaves = 8                  //// shared between all onjects///// class variable ,not instance variable 
                            pass

                        nandan = Employee()
                        pandey = Employee()

                       nandan.name = "Nandan"
                       nandan.salary = 455
                      nandan.role = "Instructor"

                        pandey.name = "Panddy"
                        pandey.salary = 4554
                        pandey.role = "Student"
                        print(nandan.__dict__)         ////  name:Nandan, salary:455, role:Instructor
                        print(Employee.no_of_leaves)    //// 8
                        print(Employee.__dict__)     /// no_of_leaves
                        Employee.no_of_leaves = 9 
                        print(Employee.__dict__)     /// no_of_leaves
                        print(Employee.no_of_leaves)  /// 9
                        nandan.no_of_leaves=10  ///// not allowed //// only class can change class variable
                        print(nandan.no_of_leaves)  ///// 9
 
 


b) self is like this in c++,java
c) __init__(self) is constructor

d) In example-(a) object nandan has name ,salary and role fields and one shared field that is no_of_leaves.
   If we want to change no_of_leaves as shown in above example then it is not allowed.
   So if we want to chage no_of_leave for only this object then create a new method that changes no_of_leaves using @classmethod decorator.


   class Employee:
       no_of_leaves = 5
       def __init__(self);
            -----
            -----
       @classmethod
       def change_leaves(cls, leaves):
           cls.no_of_leaves = leaves


   print(nandan.no_of_leaves)   /// 5
   nandan.change_leaves(8)
   print(nandan.no_of_leaves)    //// 8
   print(pandey.no_of_leaves)    /// 5
   Employee.change_leaves(35)    
   print(Employee.no_of_leaves)   /// 34
   print(pandey.no_of_leaves)    /// 34
   print(nandan.no_of_leaves)    //// 8
   
   NOTE: cls can be object or class any of them but self can only be object
   Result : class variable and specific object's class attribute can be changed.
   

-------------------------------------------------------------------------------------------------------------------------------
1) function that is decorated with class method  can be called over object or class both.
    classmethod can be used for changing class variable.
2) function that is decorated with static method can be called over object or class both.Use it if you don't want to use self or cls.
   
   
          a) Class Method as alternative constructor:

                               class Employee:
                                    no_of_leaves = 8

                                    def __init__(self, aname, asalary, arole):
                                        self.name = aname
                                        self.salary = asalary
                                        self.role = arole

                                    def printdetails(self):
                                        return f"The Name is {self.name}. Salary is {self.salary} and role is {self.role}"

                                    @classmethod
                                    def change_leaves(cls, newleaves):
                                        cls.no_of_leaves = newleaves

                                    @classmethod
                                    def from_dash(cls, string):
                                        # params = string.split("-")
                                        # print(params)
                                        # return cls(params[0], params[1], params[2])
                                        return cls(*string.split("-"))             ////// returns list  using *args

    
    
    
                                    @staticmethod
                                    def printgood(string):
                                        print("This is good " + string)
                                        
                                        
                                        
                                        
                                harry = Employee("Harry", 255, "Instructor")
                                rohan = Employee("Rohan", 455, "Student")
                                karan = Employee.from_dash("Karan-480-Student")   ///// alternative way of constructor using class methods

                                print(karan.no_of_leaves)
                                # rohan.change_leaves(34)
                                #
                                # print(harry.no_of_leaves)
   
                                Employee.printgood("Rohan")                       //// This is good rohan
                                rohan.printgood("Roha")                         //// tTis is good Roha
                

---------------------------------------------------------------------------------------------------------------------------------
python and c++ allows multiple inheritance but java does not.
----------------------------------------------------------------------------------------------------------------------------------

Operator overloading:
1) use funciton name to overload operator as to overload operator + use __add__(self), for / use __truediv__(self)  ===>> this is convention in python.

These function names are called 'Dunder methods'


2) __repr__ and __str__ ==>>> both are used to get a string representation of object.  
                        ==>>> str is more powerful than repr 
                        ==>>> repr works until str does not come into existance or explicitly called by passing object
                        ==>> repr computes the official rereentation of object
                        ===>> str computes the readable representation of object
                        ==>> repr and str are also user defined for better understanding of their created object.




                        class Employee:
                            no_of_leaves = 8

                            def __init__(self, aname, asalary, arole):
                                self.name = aname
                                self.salary = asalary
                                self.role = arole

                            def printdetails(self):
                                return f"The Name is {self.name}. Salary is {self.salary} and role is {self.role}"

                            @classmethod
                            def change_leaves(cls, newleaves):
                                cls.no_of_leaves = newleaves

                            def __add__(self, other):
                                return self.salary + other.salary

                            def __truediv__(self, other):
                                return self.salary / other.salary

                            def __repr__(self):
                                return f"Employee('{self.name}', {self.salary}, '{self.role}')"

                            def __str__(self):
                                return f"The Name is {self.name}. Salary is {self.salary} and role is {self.role}"

                        emp1 =Employee("Harry", 345, "Programmer")
                        # emp2 =Employee("Rohan", 55, "Cleaner")
                        
                        print(str(emp1))
                        print(emp1)

-----------------------------------------------------------------------------------------------------------------------------------


Setter and property decorator: ==>> property decorator allows us to use any function as attribute that means no use of () for function .


                                class Employee:
                                    def __init__(self, fname, lname):
                                        self.fname = fname
                                        self.lname = lname
                                        # self.email = f"{fname}.{lname}@codewithharry.com"

                                    def explain(self):
                                        return f"This employee is {self.fname} {self.lname}"

                                    @property
                                    def email(self):
                                        if self.fname==None or self.lname == None:
                                            return "Email is not set. Please set it using setter"
                                        return f"{self.fname}.{self.lname}@codewithharry.com"

                                    @email.setter                       //// email sets the property fname and lname that was created by constructor 
                                    def email(self, string):
                                        print("Setting now...")
                                        names = string.split("@")[0]
                                        self.fname = names.split(".")[0]
                                        self.lname = names.split(".")[1]

                                    @email.deleter                         /// email deletes the fname and lname constructed property.
                                    def email(self):
                                        self.fname = None
                                        self.lname = None


                                hindustani_supporter = Employee("Hindustani", "Supporter")
                                # nikhil_raj_pandey = Employee("Nikhil", "Raj")

                                print(hindustani_supporter.email)

                                hindustani_supporter.fname = "US"

                                print(hindustani_supporter.email)
                                hindustani_supporter.email = "this.that@codewithharry.com"
                                print(hindustani_supporter.fname)

                                del hindustani_supporter.email
                                print(hindustani_supporter.email)
                                hindustani_supporter.email = "Harry.Perry@codewithharry.com"
                                print(hindustani_supporter.email) ///////"Harry.Perry@codewithharry.com"


--------------------------------------------------------------------------------------------------------------------------------------
Object introspection : looking at details of object---->>> inspection of object


                                    skillf = Employee("Skill", "F")
                                   
                                    o = "this is a string"
                                    # print(dir(skillf))
                                    # print(id("that that"))

                                    import inspect
                                    print(inspect.getmembers(skillf))  ///// all functions of this object's class
                                    
                                    
--------------------------------------------------------------------------------------------------------------------------------------                                    


"""
Iterable - __iter__() or __getitem__()
Iterator - __next__()
Iteration -

"""

def gen(n):
    for i in range(n):
        yield i

g = gen(3)
# print(g.__next__())
# print(g.__next__())
# print(g.__next__())
# print(g.__next__())


# for i in g:
#     print(i)

h = 546546
ier = iter(h)
print(ier.__next__())
print(ier.__next__())
print(ier.__next__())
# for c in h:
#     print(c)






----------------------------------------------------------------------------------------------------------------------------------

for loop with else:

            khana = ["roti", "Sabzi", "chawal"]
            for item in khana:
                if item == "rotiroll":
                    break
            else:
                print("Your item was not found")



--------------------------------------------------------------------------------------------------------------------------------------
function caching:  stores some functin calls' value so that there is no need of rerun of function when ever called.
                : decorator @lru_cache()



import time
from functools import lru_cache

@lru_cache(maxsize=32)
def some_work(n):
    #Some task taking n seconds
    time.sleep(n)
    return n

if __name__ == '__main__':
    print("Now running some work")
    some_work(3)
    some_work(1)
    some_work(6)
    some_work(2)
    print("Done... Calling again")
    input()
    some_work(3)
    print("Called again")



------------------------------------------------------------------------------------------------------------------------------------
try  
except: when error occurs in try block then except block runs
else: if except block runs then else not , if except does not runs then else runs
finally: either try runs or except runs , finally always runs.



                        f1 = open("harry.txt")

                        try:
                            f = open("does2.txt")

                        except EOFError as e:
                            print("Print eof error aa gaya hai", e)

                        except IOError as e:
                            print("Print IO error aa gaya hai", e)

                        else:
                            print("This will run only if except is not running")

                        finally:
                            print("Run this anyway...")
                            # f.close()
                            f1.close()

                        print("Important stuff")
-----------------------------------------------------------------------------------------------------------------------------

Coroutines : When we call coroutine nothing happens, it runs only in response to the next() and send() method. 
           : whatever value we send to coroutine is captured and returned by (yield) expression.
           : A value can be send to the coroutine by send() method.
           : takes value in yield after next() method is applied to coroutines.
           : use when you have to use some part of function again and again and it takes always too much time to execute again and again.
           : so using corotuine only once time consuming part of program runs and after that whenever u call it it serves you without executing itself again.
           


                           eg)             def searcher():
                                            import time
                                            # Some 4 seconds time consuming task
                                            book = "This is a book on harry and code with harry and good"
                                            time.sleep(4)

                                            while True:
                                                text = (yield)
                                                if text in book:
                                                    print("Your text is in the book")
                                                else:
                                                    print("Text is not in the book")

                                        search = searcher()
                                        print("search started")
                                        next(search)
                                        print("Next method run")
                                        search.send("harry")

                                        search.close()
                                        search.send("harry")
                                        # input("press any key")
                                        # search.send("harry and")
                                        # input("press any key")
                                        # search.send("thi si")
                                        # input("press any key")
                                        # search.send("joker")
                                        # input("press any key")
                                        # search.send("like this video")





                      eg) # Python3 program for demonstrating 
                                                # coroutine execution 

                                                def print_name(prefix): 
                                                    print("Searching prefix:{}".format(prefix)) 
                                                    while True: 
                                                        name = (yield) 
                                                        if prefix in name: 
                                                            print(name) 

                                                # calling coroutine, nothing will happen 
                                                corou = print_name("Dear") 

                                                # This will start execution of coroutine and 
                                                # Prints first line "Searchig prefix..." 
                                                # and advance execution to the first yield expression 
                                                corou.__next__() 

                                                # sending inputs 
                                                corou.send("Atul") 
                                                corou.send("Dear Atul") 



------------------------------------------------------------------------------------------------------------------------------------
OS module:
 
 
                        import os
                        # print(dir(os))
                        # print(os.getcwd())
                        # os.chdir("C://")                         # change current working directory
                        # print(os.getcwd())
                        # f = open("harry.txt")
                        # print(os.listdir("C://"))
                        # os.makedirs("This/that")
                        # os.rename("harry.txt", "codewithharry.txt")
                        # print(os.environ.get('Path'))
                        # print(os.path.join("C:/", "/harry.txt"))

                        # print(os.path.exists("C://Program Files2"))
                        print(os.path.isfile("C://Program Files"))


----------------------------------------------------------------------------------------------------------------------------------
HTTPS requests:

                import requests
                r = requests.get("https://financialmodelingprep.com/api/company/price/AAPL")
                print(r.text)
                print(r.status_code)

                # url = "www.something.com"
                # data = {
                #     "p1":4,
                #     "p2":8
                # }
                # r2 = requests.post(url=url, data=data)

---------------------------------------------------------------------------------------------------------------------------------
json module: loads is used for parsing json from string that has json format==> s in loads stands for string
            : load is used for parsing json form file  that has jaon content
            : dumps is used for converting dictionary into json compatible format.

                import json
                data = '{"var1":"harry", "var2":56}'
                print(data)

                parsed = json.loads(data)  
                print(type(parsed))

                #Task 1 - json.load?


                data2 = {
                    "channel_name": "CodeWithHarry",
                    "cars": ['bmw', 'audi a8', 'ferrari'],
                    "fridge": ('roti', 540),
                    "isbad": False
                }

                jscomp = json.dumps(data2)
                print(jscomp)

                # Task 2 = what is sort_keys parameter in dumps

--------------------------------------------------------------------------------------------------------------------------------------
pickling: object serilization technique
       : writing python objects such as list,dictionary, tuple etc. into file.
       : dump()  // writing object in file
       : load()  // reading object from file
       : loads()  // reading byte object from file =>> s for string
       : it is important to use binary mode for read and write
                                        import pickle

                                        # Pickling a python object
                                        # cars = ["Audi", "BMW", "Maruti Suzuki", "Harryti Tuzuki"]
                                        # file = "mycar.pkl"
                                        # fileobj = open(file, 'wb')
                                        # pickle.dump(cars, fileobj)
                                        # fileobj.close()

                                        file = "mycar.pkl"
                                        fileobj = open(file, 'rb')
                                        mycar = pickle.load(fileobj)
                                        print(mycar)
                                        print(type(mycar))


                                        # pickle.loads = ?

unpickling: reading objects from file 




Pickle Module: Python pickle module is used for serializing and de-serializing a Python object structure.
               Any object in Python can be pickled so that it can be saved on disk. What pickle does is that 
               it “serializes” the object first before writing it to file. Pickling is a way to convert a 
               python object (list, dict, etc.) into a character stream. The idea is that this character stream 
               contains all the information necessary to reconstruct the object in another python script.
-----------------------------------------------------------------------------------------------------------------------------------

.py to .exe:

a) pip install pyinstaller
b) pyinstaller main.py 
If only one file required then (Although they are also get extracted like above )-->
c) pyinstaller --onefile main.py

-------------------------------------------------------------------------------------------------------------------------------------

Raise : For creating your own exception or write your own description in predefined/builtin exception/error.


                    # a = input("What is your name")
                    # b = input("How much do you earn")
                    # if int(b)==0:
                    #     raise ZeroDivisionError("b is 0 so stopping the program")
                    # if a.isnumeric():
                    #     raise Exception("Numbers are not allowed")
                    #
                    # print(f"Hello {a}")
                    # 1000 lines taking 1 hour

                    # Task - Write about 2 built in exception

                    c = input("Enter your name")
                    try:
                        print(a)

                    except Exception as e:

                        if c =="harry":
                            raise ValueError("Harry is blocked he is not allowed")

                        print("Exception handled")


 ------------------------------------------------------------------------------------------------------------------------------------
 is vs ==
 
# == - value equality - Two objects have the same value
# is - reference equality - Two references refer to the same object




                       a=[7,4,5]
                       b=a                                 ///// creating same reference
                       b==a       //true
                       b is a     //true
                       b[0] =2
                       print(a)   // 2,4,5
                       c = a[:]                           //// creating new copy 
                       c is a     // false
                       c is b       /// false
                       c==a        /// true
                       c==b        // true




       
                        a =[6, 4 , "34"]
                        b = [6, 4 , "34"]
                        print(b is a)           ///// false
                           b ==a           ///true



-----------------------------------------------------------------------------------------------------------------------------------


Command line utility: argparse utility


                            import argparse
                            import sys

                            def calc(args):
                                if args.o == 'add':
                                    return args.x + args.y

                                elif args.o == 'mul':
                                    return args.x * args.y

                                elif args.o == 'sub':
                                    return args.x - args.y

                                elif args.o == 'div':
                                    return args.x / args.y

                                else:
                                    return "Something went wrong"

                            if __name__ == '__main__':
                                parser = argparse.ArgumentParser()
                                parser.add_argument('--x', type=float, default=1.0,
                                                    help="Enter first number. This is a utility for calculation.")

                                parser.add_argument('--y', type=float, default=3.0,
                                                    help="Enter second number. This is a utility for calculation. ")

                                parser.add_argument('--o', type=str, default="add",
                                                    help="This is a utility for calculation. ")

                                args = parser.parse_args()
                                sys.stdout.write(str(calc(args)))          /// writing on command line



------------------------------------------------------------------------------------------------------------------------------------

Package: creating package

a) path -->  paent_folder/setup.py :

                from setuptools import setup
                setup(name="packageharry",
                version="0.3",
                description="This is code with harry package",
                long_description = "This is a very very long description",
                author="Harry",
                packages=['packageharry'],
                install_requires=[pandas])



b) path-->  parent_folder/package_folder/__init__.py :
                        import pandas
                        class Achha:
                            def __init__(self):
                                print("Constructor ban gaya")

                        def achhafunc(self, number):
                            print("This is a function")
                            return number



c) pip install wheel

d) run ==>> python sdist bdist_wheel
           
e) created folder of dist -->>>> here exists wheel file    ---->> path: parentfolder/dist    

f) install this wheel file -->>> pip install wheel_file     -->> that is actually installing my package--> hoorrah distribute this package.....

g) if some change occured in __init__.py file then create new version.


h) which code is inside init.py() is converted into package.





--------------------------------------------------------------------------------------------------------------------------------------

creating virtual environent and requirements==>>detect major python version

    file of virtual environement : run_VirtualEnv.bat
                                                @echo off

                                                ::-- Get Python major version
                                                setlocal
                                                for /f "tokens=2 delims=. " %%f in ('python --version') do set majorVersion=%%f
                                                echo Detected Python major version: %majorVersion%

                                                ::-- Create virtual environment
                                                python -m venv .venv

                                                ::--- Activate virtual environment
                                                call .venv\Scripts\activate.bat

                                                ::-- Upgrade pip at virtual environment
                                                python -m pip install --upgrade pip

                                                ::-- Install requirements at virtual environment
                                                if "%majorVersion%"=="2" (
                                                  pip install -r requirements2x.txt
                                                ) else (
                                                  pip install -r requirements.txt
                                                )

                                                ::-- Run main program at virtual environment
                                                python main.py

                                                ::-- Deactivate virtual environment
                                                call .venv\Scripts\deactivate.bat

                                                pause




       
       
       ---------------
       if python3 detected:
           requiremnts.txt will be like:
                        pandas==1.0.3
                        python-dateutil==2.8.1
                        pytz==2019.3
                        requests==2.23.0
                        six==1.14.0
                        tqdm==4.45.0
                        urllib3==1.25.8
                        xlrd==1.2.0
                        
         -----------------
         if python2 detected:
              requirements2.txt will ne like 
                        pytz==2019.3
                        requests==2.23.0
                        six==1.14.0
                        tqdm==4.45.0
                        urllib3==1.25.8
                        xlrd==1.2.0
         
 -------------------------------------------------------------------------------------------------------------------------------------
 
 
 
 
 
 
